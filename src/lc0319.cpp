// 1 -> 1

// 2:
// 1 1
// 1 0 -> 1

// 3:
// 1 1 1
// 1 0 1
// 1 0 0 -> 1

// 4:
// 1 1 1 1
// 1 0 1 0
// 1 0 0 0
// 1 0 0 1 -> 2

// 5:
// 1 1 1 1 1
// 1 0 1 0 1
// 1 0 0 0 1
// 1 0 0 1 1
// 1 0 0 1 0 -> 2

// 6:
// 1 1 1 1 1 1
// 1 0 1 0 1 0
// 1 0 0 0 1 1
// 1 0 0 1 1 1
// 1 0 0 1 0 1
// 1 0 0 1 0 0 -> 2

// 7:
// 1 1 1 1 1 1 1
// 1 0 1 0 1 0 1
// 1 0 0 0 1 1 1
// 1 0 0 1 1 1 1
// 1 0 0 1 0 1 1
// 1 0 0 1 0 0 1
// 1 0 0 1 0 0 0 -> 2

// 8:
// 1 1 1 1 1 1 1 1
// 1 0 1 0 1 0 1 0
// 1 0 0 0 1 1 1 0
// 1 0 0 1 1 1 1 1
// 1 0 0 1 0 1 1 1
// 1 0 0 1 0 0 1 1
// 1 0 0 1 0 0 0 1
// 1 0 0 1 0 0 0 0 -> 2

// Each bit gets flipped once for each factor.
// We need to count the number of squares under the number.
class Solution {
public:
  int bulbSwitch(int n) { return std::sqrt(n); }
};
